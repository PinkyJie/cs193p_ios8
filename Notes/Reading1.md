The Swift Programing Language 阅读笔记1
-----
* 多行注释`/* */`可以嵌套。
* `nil`不可以被赋给非可选类型的变量或常量。

###元组
* 元组的分解：`let (a, b) = tuple`，注意这里的括号。
* 元组分解时使用`_`忽略某个值。
* 元组可以使用类似`a.0`的下标语法来访问其元素。
* 定义元组时可以给其元素命名，如`let a = (aaa: 200, bbb: "OK")`，命名后可以使用类似`a.aaa`的语法访问其元素。

###可选绑定
* 可选绑定可用于`if`或`while`语句，如果可选类型有值返回，则为真，并且可选变量在引用时不需要被强制解析。如：
```
if let actualNumber = possibleNumber.toInt() {
  println("xxx \(actualNumber)")
} else {
  xxxx
}
```

###隐式解析可选类型
* 有些情况下，一个可选类型的变量在首次被赋值后可以确定其以后总是有值的。为了方便以后引用变量时不需要每次都使用强制解析`!`，可以在声明这个变量时将其类型声明为`String!`。原本的`?`变成了`!`，但其仍然是可选类型，outlet类型的变量就是一个很好地例子。

###运算符
* 赋值运算符`=`不返回值，防止在`if`语句判断是错将`==`写成`=`。
* 加减乘除默认会检查结果是否溢出。
* 求余运算符`%`：`9 % 4` => `9 = (2 x 4) + 1`，该运算符同样可以用于浮点数。
* 空合运算符`??`：`a ?? b` => `a != nil ? a! : b`，其中a的类型必须是可选类型，b的类型必须于a有值时的类型一致。
* 区间运算符：`a...b`代表同时包含a和b的区间，`a..<b`代表不包含b的区间，常用于循环。

###字符串
* String类型与NSString类型是对等的。
* String类型在参数传递时使用值传递，即传进函数中的变量不会被更改。
* 全局函数`countElements`可返回字符串的长度。
* Unicode表示：
    * 每个字符都是Unicode的标量(21位数字)
    * 通过`.utf8`返回UTF-8表示，每一个都是UInt8类型
    * 通过`.utf16`返回UTF-16表示，每一个都是UInt16类型
    * 通过`.unicodeScalars`返回Unicode标量表示，每一个都是UInt32类型

###数组
* 只能存储同一类型的元素，与NSArray不同。
* 数组的类型一般使用`Array<Type>`来声明，也可以直接用简短的`[Type]`来声明。
* 使用下标使可以使用上面的区间运算符，如`a[4...6]`，使用区间运算符在左侧时，右侧的数量可以比左侧少，如`a[4...6] = [1]`，这样就会使数组的元素个数减少为4个。
* 常用属性和方法：
    * `count`属性获取长度。
    * `append`方法和`+=`运算符，在尾部插入元素。
    * `insert(newEle, atIndex)`方法在任意位置插入元素。
    * `removeAtIndex(idx)`删除指定位置的元素。
    * `removeLast`方法移除最后一个元素并返回。
* 遍历：`for x in arr`或`for (idx, val) in enumerate(arr)`
* 创建空数组：`[Int]()`或可推导类型的情况下直接使用`[]`。

###字典
* 同样Key和Value的类型是确定的。
* 声明：`Dictionary<KeyType, ValueType>`或`[KeyType:ValueType]`。
* 注意，字典同样使用`[]`，而不是其他语言的`{}`。
* `dict[key]`返回的类型都是可选类型，因为key有可能不存在。
* 方法`updateValue(value, forKey)`可用于设置或更新某个key，返回值也为可选类型，如果key不存在则为nil，存在则为更新前的值。
* 方法`removeValueForKey`，移除某个键值对，同样返回值为可选的，返回删除前的值。
* 创建空字典：`Dictionary<KeyType, ValueType>()`或可推导类型的情况下直接使用`[:]`。

###控制流
* `for x in arr`循环中的x不需要手动声明，但其声明周期只在循环体中有效。
* 如果不关心循环变量本身，可以使用`_`。
* switch不需要使用break，但可以使用break显式的表明忽略某个case分支，匹配到break的分支会直接结束switch。
* switch不允许出现空的case语句，也就是说不允许多个case执行同样的语句块，如果要达到类似C语言的效果，可以显式的使用fallthrough关键字。
* switch的case语句除支持基本类型的匹配外，还支持：
    * 使用逗号匹配多个值：如`case 1, 2, 3`。
    * 区间匹配：如`case 1...3`。
    * 元组匹配：如`case (1, 2)`或`case (_, 2)`。
* 元组匹配还支持一些特殊的用法：
    * 将匹配的值绑定到一个变量上：如`case (let x, 0)`。
    * 使用where做条件匹配：如`case let (x, y) where x == y`。
* 循环前面可以使用标签，如`aaa: while xxx`，这样在多层的循环中可以显式的指明break要退出哪个循环，如`break aaa`。

###函数
* 每个函数都有一种类型，包括参数类型和返回值类型。
* 函数声明：`func functionName(paramName: Type) -> returnType {}`。
* 没有返回值的函数会返回`Void`，它实际上是空元组，即`()`。
* 需要返回多个值时可以返回元组，可以使用函数体里的命名，如函数体中`return (a,b,c)`，则在调用函数时可以使用`returnVal.a`来引用其元素。
* 外部参数名称，类似于Obj-C中的概念。如`func funcName(externalParameterName localParameterName: Type)`，使用这种带外部参数名的方式定义函数，则调用者在调用函数的时候也不必使用外部参数名，如`funcName(externalParameterName: aaa)`。
* 如果外部参数名称与局部参数名称相同，则可以简单的使用`#`号来表示，如`func funcName(#localParameterName: Type)`即可，通常情况下都可以这样用。
* 有默认值的参数通常放在参数表最后的位置，并且默认情况下，它的局部参数名就是外部参数名，就好像你手动加了`#`一样，所以调用时对于有默认值的参数必须写明外部参数明。当你想忽略这个外部参数名时，可以使用`_`做为参数名称。
* 可变长参数，类型为`Type...`，在函数体内可以当做Type型的数组使用。如果一个函数最多只能有一个可变长的参数，且必须放在参数表的最后。
* 参数默认是常量的，即在函数体中不可改变，否则会报错。如果想让其变成变量，在定义函数时在参数前加`var`即可，但是对于变量参数的更改只在函数的生命周期内有效，也就是说，不影响外面的。基于这个特性，你可以在调用函数时将一个常量作为变量参数传进去，对于这个参数的更改不会影响这个常量。
* 在参数前面加上`inout`则这个参数就相当于引用传递了，在函数体中的变化将影响函数体外的变量。在调用时需要在实参前加`&`，表明是引用传递。
* 嵌套函数：定义在其他函数中的函数，对外不可见，仅可被包含其的函数（enclosing function）所调用或返回。

###闭包
* 函数作为参数传递（闭包）时的其简写过程：
    * 完整语法： 
    ```
    { (s1: String, s2: String) -> Bool in
      return s1 > s2
    }
    ```
    * 省略类型:由于在函数声明时就定义了其函数参数的类型，根绝类型推导的原则所有参数可以省略，即`{ s1, s2 in return s1 > s2 }`。
    * 单行函数体可省略return关键字：`{ s1, s2 in s1 > s2 }`。
    * 参数名称可简写：`{ $0 > $1 }`。
    * 针对比较字符串这个特例，可以直接传`>`这个运算符，因为这个运算符有一个针对字符串比较的重载，即`sorted(names, >)`。
* 当函数的最后一个参数是闭包时，可以使用“尾随闭包”来增强可读性。即将函数体写在括号外面，如`sorted(names) { $0 > $1 }`。如果闭包是唯一的一个参数，则括号也可以省略不写。这种写法比较适用于当闭包的函数体很长，一行写不下的情况。如：
```
numbers.map {
  xxxx
}
```
* 值捕获：闭包在其定义的上下文中捕获常量或变量，即可定义这些常量和变量的原域已经不存在，闭包依然可以引用或更改这些值。

